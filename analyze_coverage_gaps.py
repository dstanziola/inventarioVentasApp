#!/usr/bin/env python3
"""
An√°lisis de Cobertura de Tests - FASE 5A
========================================

Script para realizar an√°lisis completo de cobertura de tests y identificar 
gaps para alcanzar el objetivo de ‚â•95% cobertura.

OBJETIVOS:
1. Ejecutar pytest con an√°lisis de cobertura completo
2. Generar reporte HTML detallado  
3. Identificar m√≥dulos con baja cobertura
4. Generar recomendaciones espec√≠ficas para alcanzar 95%
5. Preparar plan de acci√≥n para completar FASE 5A

Autor: Sistema de Inventario Copy Point S.A.
Fecha: Julio 4, 2025 - An√°lisis Cobertura FASE 5A
Protocolo: TDD - An√°lisis post-correcciones
"""

import os
import sys
import subprocess
import json
import time
from typing import Dict, List, Any, Tuple

class CoverageAnalyzer:
    """Analizador de cobertura de tests para FASE 5A."""
    
    def __init__(self, project_root: str = "D:\\inventario_app2"):
        """
        Inicializar analizador de cobertura.
        
        Args:
            project_root: Ruta ra√≠z del proyecto
        """
        self.project_root = project_root
        self.coverage_data = {}
        self.recommendations = []
        self.critical_gaps = []
        
        print(f"üìä === AN√ÅLISIS DE COBERTURA FASE 5A ===")
        print(f"üìÅ Proyecto: {project_root}")
        print(f"üéØ Objetivo: Identificar gaps para alcanzar ‚â•95% cobertura")
        print(f"üìã Metodolog√≠a: An√°lisis sistem√°tico post-TDD")
    
    def run_coverage_analysis(self) -> bool:
        """
        Ejecutar an√°lisis completo de cobertura.
        
        Returns:
            True si el an√°lisis fue exitoso
        """
        print(f"\n1Ô∏è‚É£ EJECUTANDO: An√°lisis completo de cobertura...")
        
        try:
            # Ejecutar pytest con cobertura completa
            result = subprocess.run([
                sys.executable, '-m', 'pytest',
                '--cov=src',
                '--cov-report=html',
                '--cov-report=term-missing',
                '--cov-report=json',
                '--cov-fail-under=0',  # No fallar por cobertura baja
                '-v',
                'tests/'
            ], capture_output=True, text=True, cwd=self.project_root, timeout=300)
            
            print(f"   üìä Comando ejecutado: pytest --cov=src --cov-report=html tests/")
            print(f"   ‚è±Ô∏è C√≥digo de retorno: {result.returncode}")
            
            # Mostrar salida resumida
            if result.stdout:
                lines = result.stdout.split('\n')
                coverage_lines = [line for line in lines if 'TOTAL' in line or '%' in line][-10:]
                print(f"   üìà Resultados de cobertura:")
                for line in coverage_lines:
                    if line.strip():
                        print(f"      {line}")
            
            # Verificar si se generaron reportes
            html_report_path = os.path.join(self.project_root, 'htmlcov', 'index.html')
            json_report_path = os.path.join(self.project_root, 'coverage.json')
            
            if os.path.exists(html_report_path):
                print(f"   ‚úÖ Reporte HTML generado: htmlcov/index.html")
            
            if os.path.exists(json_report_path):
                print(f"   ‚úÖ Reporte JSON generado: coverage.json")
                self.load_coverage_data(json_report_path)
            
            return True
            
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ Timeout en an√°lisis de cobertura (5 min)")
            return False
        except Exception as e:
            print(f"   ‚ùå Error en an√°lisis de cobertura: {e}")
            return False
    
    def load_coverage_data(self, json_path: str):
        """
        Cargar datos de cobertura desde archivo JSON.
        
        Args:
            json_path: Ruta al archivo JSON de cobertura
        """
        try:
            with open(json_path, 'r', encoding='utf-8') as f:
                self.coverage_data = json.load(f)
            print(f"   üìã Datos de cobertura cargados desde JSON")
        except Exception as e:
            print(f"   ‚ö†Ô∏è No se pudo cargar datos JSON: {e}")
    
    def analyze_coverage_gaps(self):
        """Analizar gaps de cobertura y generar recomendaciones."""
        print(f"\n2Ô∏è‚É£ ANALIZANDO: Gaps de cobertura...")
        
        if not self.coverage_data:
            print(f"   ‚ö†Ô∏è No hay datos de cobertura disponibles para an√°lisis")
            self.analyze_manual_coverage_gaps()
            return
        
        try:
            files = self.coverage_data.get('files', {})
            total_coverage = self.coverage_data.get('totals', {}).get('percent_covered', 0)
            
            print(f"   üìä Cobertura total actual: {total_coverage:.1f}%")
            print(f"   üéØ Objetivo: ‚â•95.0%")
            print(f"   üìà Gap a cubrir: {max(0, 95.0 - total_coverage):.1f}%")
            
            # Identificar archivos con baja cobertura
            low_coverage_files = []
            
            for file_path, file_data in files.items():
                if 'summary' in file_data:
                    coverage_percent = file_data['summary'].get('percent_covered', 0)
                    if coverage_percent < 90:  # Menos del 90%
                        low_coverage_files.append((file_path, coverage_percent))
            
            # Ordenar por cobertura ascendente
            low_coverage_files.sort(key=lambda x: x[1])
            
            print(f"\n   üìâ ARCHIVOS CON BAJA COBERTURA (<90%):")
            for file_path, coverage in low_coverage_files[:10]:  # Top 10
                file_name = os.path.basename(file_path)
                print(f"      ‚Ä¢ {file_name}: {coverage:.1f}%")
                
                if coverage < 70:
                    self.critical_gaps.append(file_name)
                
                self.recommendations.append(f"Aumentar tests para {file_name} (actual: {coverage:.1f}%)")
            
            if not low_coverage_files:
                print(f"      ‚úÖ Todos los archivos tienen >90% cobertura")
            
        except Exception as e:
            print(f"   ‚ùå Error analizando gaps de cobertura: {e}")
            self.analyze_manual_coverage_gaps()
    
    def analyze_manual_coverage_gaps(self):
        """An√°lisis manual de gaps basado en estructura del proyecto."""
        print(f"   üîç Realizando an√°lisis manual de cobertura...")
        
        # M√≥dulos cr√≠ticos que deben tener alta cobertura
        critical_modules = [
            'src/services/product_service.py',
            'src/services/category_service.py', 
            'src/services/sales_service.py',
            'src/services/client_service.py',
            'src/db/database.py',
            'src/helpers/validation_helper.py',
            'src/helpers/logging_helper.py'
        ]
        
        print(f"   üìã Verificando m√≥dulos cr√≠ticos:")
        for module in critical_modules:
            module_path = os.path.join(self.project_root, module)
            if os.path.exists(module_path):
                print(f"      ‚úÖ {os.path.basename(module)}")
            else:
                print(f"      ‚ùå {os.path.basename(module)} - No encontrado")
                self.critical_gaps.append(os.path.basename(module))
        
        # Generar recomendaciones basadas en estructura
        self.recommendations.extend([
            "Completar tests unitarios para ProductService",
            "Agregar tests de integraci√≥n para SalesService", 
            "Implementar tests de validaci√≥n para helpers",
            "Crear tests de UI para formularios principales",
            "Agregar tests de performance para servicios cr√≠ticos"
        ])
    
    def generate_recommendations(self):
        """Generar recomendaciones espec√≠ficas para alcanzar 95% cobertura."""
        print(f"\n3Ô∏è‚É£ GENERANDO: Recomendaciones para alcanzar 95% cobertura...")
        
        # Recomendaciones por categor√≠a
        test_categories = {
            "Tests Unitarios Faltantes": [
                "test_product_service_edge_cases.py - Casos extremos ProductService",
                "test_category_validation_complete.py - Validaci√≥n completa categor√≠as",
                "test_sales_calculations.py - C√°lculos de ventas e impuestos",
                "test_database_transactions.py - Transacciones de BD complejas"
            ],
            "Tests de Integraci√≥n Necesarios": [
                "test_complete_sale_flow.py - Flujo completo de venta",
                "test_inventory_movements.py - Movimientos de inventario",
                "test_report_generation.py - Generaci√≥n de reportes",
                "test_user_authentication_flow.py - Flujo de autenticaci√≥n"
            ],
            "Tests de UI Cr√≠ticos": [
                "test_main_window_functionality.py - Funcionalidad ventana principal",
                "test_product_form_validation.py - Validaci√≥n formulario productos",
                "test_sales_form_complete.py - Formulario de ventas completo",
                "test_report_forms.py - Formularios de reportes"
            ],
            "Tests de Casos Especiales": [
                "test_error_handling.py - Manejo de errores",
                "test_database_corruption.py - Corrupci√≥n de BD",
                "test_concurrent_operations.py - Operaciones concurrentes",
                "test_data_validation_edge_cases.py - Casos extremos validaci√≥n"
            ]
        }
        
        print(f"   üìã TESTS RECOMENDADOS POR CATEGOR√çA:")
        for category, tests in test_categories.items():
            print(f"\n      üéØ {category}:")
            for test in tests:
                print(f"         ‚Ä¢ {test}")
        
        # Prioridades
        print(f"\n   üö® PRIORIDAD ALTA (cr√≠ticos para 95%):")
        priority_tests = [
            "Tests unitarios completos para ProductService",
            "Tests de integraci√≥n para flujo de ventas",
            "Tests de validaci√≥n para helpers cr√≠ticos",
            "Tests de UI para ventana principal"
        ]
        
        for test in priority_tests:
            print(f"      üî• {test}")
        
        # Estimaci√≥n de esfuerzo
        print(f"\n   ‚è±Ô∏è ESTIMACI√ìN DE ESFUERZO:")
        print(f"      ‚Ä¢ Tests unitarios: 2-3 d√≠as")
        print(f"      ‚Ä¢ Tests de integraci√≥n: 1-2 d√≠as") 
        print(f"      ‚Ä¢ Tests de UI: 1-2 d√≠as")
        print(f"      ‚Ä¢ Tests de casos especiales: 1 d√≠a")
        print(f"      üìä Total estimado: 5-8 d√≠as para alcanzar 95%")
    
    def create_test_templates(self):
        """Crear templates de tests prioritarios."""
        print(f"\n4Ô∏è‚É£ CREANDO: Templates de tests prioritarios...")
        
        # Template para test unitario cr√≠tico
        template_path = os.path.join(self.project_root, 'tests', 'test_coverage_gap_template.py')
        
        template_content = '''"""
Template para Tests de Cobertura - FASE 5A
==========================================

Template para completar tests cr√≠ticos identificados en an√°lisis de cobertura.
Copiar y adaptar para cada m√≥dulo que necesite tests adicionales.

OBJETIVO: Alcanzar ‚â•95% cobertura total
PRIORIDAD: Alta - Cr√≠tico para completar FASE 5A

Autor: Sistema de Inventario Copy Point S.A.
Fecha: Julio 4, 2025 - Template Tests Cobertura
"""

import unittest
import tempfile
import os
import sys
from unittest.mock import patch, MagicMock

# Agregar path del proyecto
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

class TestCoverageGapTemplate(unittest.TestCase):
    """Template para tests de cobertura cr√≠ticos."""
    
    def setUp(self):
        """Configurar ambiente de test."""
        # Configurar BD temporal
        self.test_db_path = tempfile.mktemp(suffix='.db')
        
        # Configurar mocks si es necesario
        self.mock_data = {}
    
    def tearDown(self):
        """Limpiar despu√©s de tests."""
        if os.path.exists(self.test_db_path):
            os.unlink(self.test_db_path)
    
    def test_critical_functionality_1(self):
        """Test: Funcionalidad cr√≠tica 1 debe funcionar correctamente."""
        # TODO: Implementar test espec√≠fico
        self.assertTrue(True, "Template - implementar test real")
    
    def test_edge_case_handling(self):
        """Test: Manejo de casos extremos debe ser robusto."""
        # TODO: Implementar casos extremos
        self.assertTrue(True, "Template - implementar casos extremos")
    
    def test_error_conditions(self):
        """Test: Condiciones de error deben manejarse correctamente."""
        # TODO: Implementar manejo de errores
        self.assertTrue(True, "Template - implementar manejo errores")
    
    def test_integration_scenario(self):
        """Test: Escenario de integraci√≥n debe funcionar end-to-end."""
        # TODO: Implementar test de integraci√≥n
        self.assertTrue(True, "Template - implementar integraci√≥n")


if __name__ == '__main__':
    unittest.main()
'''
        
        try:
            with open(template_path, 'w', encoding='utf-8') as f:
                f.write(template_content)
            print(f"   ‚úÖ Template creado: tests/test_coverage_gap_template.py")
            print(f"   üìã Copiar y adaptar para cada m√≥dulo que necesite tests")
        except Exception as e:
            print(f"   ‚ùå Error creando template: {e}")
    
    def generate_final_report(self):
        """Generar reporte final con plan de acci√≥n."""
        print(f"\nüìä === REPORTE FINAL DE COBERTURA ===")
        print(f"="*60)
        
        print(f"üéØ OBJETIVO FASE 5A: Alcanzar ‚â•95% cobertura de tests")
        
        if self.coverage_data:
            total_coverage = self.coverage_data.get('totals', {}).get('percent_covered', 0)
            print(f"üìà COBERTURA ACTUAL: {total_coverage:.1f}%")
            print(f"üìä GAP RESTANTE: {max(0, 95.0 - total_coverage):.1f}%")
        else:
            print(f"üìà COBERTURA ACTUAL: Pendiente de an√°lisis")
            print(f"üìä GAP RESTANTE: Por determinar")
        
        print(f"\nüö® GAPS CR√çTICOS IDENTIFICADOS ({len(self.critical_gaps)}):")
        for gap in self.critical_gaps[:5]:  # Top 5
            print(f"   ‚Ä¢ {gap}")
        
        print(f"\nüìã RECOMENDACIONES PRIORITARIAS ({len(self.recommendations[:5])}):")
        for rec in self.recommendations[:5]:  # Top 5
            print(f"   ‚Ä¢ {rec}")
        
        print(f"\nüéØ PLAN DE ACCI√ìN INMEDIATO:")
        action_plan = [
            "1. Revisar reporte HTML detallado: htmlcov/index.html",
            "2. Usar template creado para completar tests faltantes",
            "3. Priorizar tests unitarios para servicios cr√≠ticos",
            "4. Implementar tests de integraci√≥n para flujos principales",
            "5. Ejecutar an√°lisis de cobertura despu√©s de cada batch de tests"
        ]
        
        for action in action_plan:
            print(f"   {action}")
        
        print(f"\n‚è±Ô∏è TIEMPO ESTIMADO PARA COMPLETAR:")
        print(f"   ‚Ä¢ Tests cr√≠ticos: 3-5 d√≠as")
        print(f"   ‚Ä¢ Validaci√≥n final: 1 d√≠a")
        print(f"   ‚Ä¢ TOTAL: 4-6 d√≠as para completar FASE 5A")
        
        print(f"\nüéâ PR√ìXIMO MILESTONE:")
        print(f"   ‚úÖ Completar tests identificados")
        print(f"   ‚úÖ Alcanzar ‚â•95% cobertura")
        print(f"   ‚úÖ Finalizar FASE 5A")
        print(f"   ‚úÖ Preparar para deployment final")
    
    def run_complete_analysis(self) -> bool:
        """
        Ejecutar an√°lisis completo de cobertura.
        
        Returns:
            True si el an√°lisis fue exitoso
        """
        print(f"\nüîç EJECUTANDO AN√ÅLISIS COMPLETO DE COBERTURA...")
        print(f"="*60)
        
        # Pasos del an√°lisis
        analysis_steps = [
            self.run_coverage_analysis,
            self.analyze_coverage_gaps,
            self.generate_recommendations,
            self.create_test_templates
        ]
        
        # Ejecutar an√°lisis paso a paso
        success = True
        for step_func in analysis_steps:
            try:
                if not step_func():
                    success = False
                time.sleep(1)  # Pausa entre pasos
            except Exception as e:
                print(f"   üí• Error en an√°lisis: {e}")
                success = False
        
        # Generar reporte final
        self.generate_final_report()
        
        return success


def run_coverage_analysis():
    """Funci√≥n principal para an√°lisis de cobertura."""
    print("\n" + "="*70)
    print("üìä AN√ÅLISIS DE COBERTURA FASE 5A")
    print("="*70)
    print("üéØ Objetivo: Identificar gaps para alcanzar ‚â•95% cobertura")
    print("üìã Metodolog√≠a: An√°lisis sistem√°tico post-TDD")
    print("üìà Resultado esperado: Plan espec√≠fico para completar tests")
    print("="*70)
    
    analyzer = CoverageAnalyzer()
    success = analyzer.run_complete_analysis()
    
    print("\n" + "="*70)
    print("üìä AN√ÅLISIS DE COBERTURA COMPLETADO")
    print("="*70)
    
    if success:
        print("‚úÖ AN√ÅLISIS EXITOSO")
        print("üìã Plan de acci√≥n generado para alcanzar 95% cobertura")
        print("üéØ Pr√≥ximo paso: Implementar tests identificados")
        return True
    else:
        print("‚ö†Ô∏è AN√ÅLISIS CON PROBLEMAS")
        print("üîç Revisar errores y intentar nuevamente")
        return False


if __name__ == '__main__':
    print("üìä Iniciando An√°lisis de Cobertura FASE 5A...")
    success = run_coverage_analysis()
    
    if success:
        print(f"\nüìà AN√ÅLISIS COMPLETADO - Plan de acci√≥n disponible")
        sys.exit(0)
    else:
        print(f"\n‚ö†Ô∏è AN√ÅLISIS INCOMPLETO - Revisar problemas")
        sys.exit(1)
