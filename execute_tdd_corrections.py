#!/usr/bin/env python3
"""
EJECUTOR DE CORRECCIONES TDD - FASE 5A
======================================

Script para ejecutar y validar todas las correcciones TDD implementadas.
Sigue el protocolo TDD estricto: ejecutar correcciones y validar resultados.

OBJETIVOS:
1. Ejecutar correcciones cr√≠ticas TDD en orden
2. Validar cada correcci√≥n individualmente  
3. Generar reporte completo de resultados
4. Preparar sistema para an√°lisis de cobertura

Autor: Sistema de Inventario Copy Point S.A.
Fecha: Julio 4, 2025 - Ejecuci√≥n TDD FASE 5A
Protocolo: TDD - Validaci√≥n post-implementaci√≥n
"""

import os
import sys
import subprocess
import time
from typing import Dict, List, Any, Tuple

class TDDCorrectionsExecutor:
    """Ejecutor y validador de correcciones TDD."""
    
    def __init__(self, project_root: str = "D:\\inventario_app2"):
        """
        Inicializar ejecutor TDD.
        
        Args:
            project_root: Ruta ra√≠z del proyecto
        """
        self.project_root = project_root
        self.execution_results = {}
        self.validation_results = {}
        self.overall_success = True
        
        print(f"üöÄ === EJECUTOR CORRECCIONES TDD FASE 5A ===")
        print(f"üìÅ Proyecto: {project_root}")
        print(f"üéØ Objetivo: Validar correcciones implementadas")
        print(f"üìã Protocolo: TDD - Ejecuci√≥n y validaci√≥n")
    
    def execute_step_01_install_psutil(self) -> bool:
        """
        Paso 1: Verificar e instalar psutil.
        
        Returns:
            True si psutil est√° disponible
        """
        print(f"\n1Ô∏è‚É£ EJECUTANDO: Verificaci√≥n e instalaci√≥n de psutil...")
        
        try:
            # Ejecutar verificaci√≥n de psutil
            result = subprocess.run([
                sys.executable, 
                os.path.join(self.project_root, 'check_psutil.py')
            ], capture_output=True, text=True, cwd=self.project_root, timeout=120)
            
            if result.returncode == 0:
                print(f"   ‚úÖ psutil verificado e instalado correctamente")
                print(f"   üìÑ Salida: {result.stdout.strip()}")
                self.execution_results['psutil_installation'] = True
                return True
            else:
                print(f"   ‚ùå Error en verificaci√≥n/instalaci√≥n de psutil")
                print(f"   üìÑ Error: {result.stderr}")
                self.execution_results['psutil_installation'] = False
                self.overall_success = False
                return False
                
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ Timeout en instalaci√≥n de psutil")
            self.execution_results['psutil_installation'] = False
            self.overall_success = False
            return False
        except Exception as e:
            print(f"   ‚ùå Excepci√≥n en instalaci√≥n de psutil: {e}")
            self.execution_results['psutil_installation'] = False
            self.overall_success = False
            return False
    
    def execute_step_02_validate_quick_fixes(self) -> bool:
        """
        Paso 2: Ejecutar validaci√≥n r√°pida de correcciones.
        
        Returns:
            True si todas las validaciones pasan
        """
        print(f"\n2Ô∏è‚É£ EJECUTANDO: Validaci√≥n r√°pida de correcciones...")
        
        try:
            # Ejecutar validaci√≥n r√°pida
            result = subprocess.run([
                sys.executable,
                os.path.join(self.project_root, 'validate_quick_fixes.py')
            ], capture_output=True, text=True, cwd=self.project_root, timeout=60)
            
            if result.returncode == 0:
                print(f"   ‚úÖ Validaci√≥n r√°pida exitosa")
                print(f"   üìä Resultado: Todas las correcciones funcionando")
                self.execution_results['quick_validation'] = True
                return True
            else:
                print(f"   ‚ùå Validaci√≥n r√°pida fall√≥")
                print(f"   üìÑ Salida: {result.stdout}")
                print(f"   üìÑ Error: {result.stderr}")
                self.execution_results['quick_validation'] = False
                self.overall_success = False
                return False
                
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ Timeout en validaci√≥n r√°pida")
            self.execution_results['quick_validation'] = False
            self.overall_success = False
            return False
        except Exception as e:
            print(f"   ‚ùå Excepci√≥n en validaci√≥n r√°pida: {e}")
            self.execution_results['quick_validation'] = False
            self.overall_success = False
            return False
    
    def execute_step_03_pytest_collection_test(self) -> bool:
        """
        Paso 3: Validar que pytest puede recolectar tests.
        
        Returns:
            True si pytest collection funciona
        """
        print(f"\n3Ô∏è‚É£ EJECUTANDO: Validaci√≥n de pytest collection...")
        
        try:
            # Ejecutar test de collection
            result = subprocess.run([
                sys.executable,
                os.path.join(self.project_root, 'test_pytest_collection.py')
            ], capture_output=True, text=True, cwd=self.project_root, timeout=90)
            
            if result.returncode == 0:
                print(f"   ‚úÖ pytest collection funcional")
                print(f"   üìä pytest puede recolectar tests sin errores")
                self.execution_results['pytest_collection'] = True
                return True
            else:
                print(f"   ‚ùå pytest collection fall√≥")
                print(f"   üìÑ Salida: {result.stdout}")
                print(f"   üìÑ Error: {result.stderr}")
                self.execution_results['pytest_collection'] = False
                self.overall_success = False
                return False
                
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ Timeout en pytest collection")
            self.execution_results['pytest_collection'] = False
            self.overall_success = False
            return False
        except Exception as e:
            print(f"   ‚ùå Excepci√≥n en pytest collection: {e}")
            self.execution_results['pytest_collection'] = False
            self.overall_success = False
            return False
    
    def execute_step_04_run_critical_tdd_test(self) -> bool:
        """
        Paso 4: Ejecutar test TDD cr√≠tico de validaci√≥n.
        
        Returns:
            True si el test TDD pasa
        """
        print(f"\n4Ô∏è‚É£ EJECUTANDO: Test TDD cr√≠tico de validaci√≥n...")
        
        try:
            # Ejecutar test TDD cr√≠tico
            result = subprocess.run([
                sys.executable,
                os.path.join(self.project_root, 'tests', 'test_critical_fixes_validation.py')
            ], capture_output=True, text=True, cwd=self.project_root, timeout=120)
            
            # Analizar resultado
            success_indicators = [
                "tests TDD ejecutados",
                "Tests exitosos", 
                "TODAS LAS VALIDACIONES EXITOSAS"
            ]
            
            output = result.stdout + result.stderr
            has_success_indicators = any(indicator in output for indicator in success_indicators)
            
            if result.returncode == 0 or has_success_indicators:
                print(f"   ‚úÖ Test TDD cr√≠tico exitoso")
                print(f"   üìä Validaciones TDD completadas")
                self.execution_results['tdd_critical_test'] = True
                return True
            else:
                print(f"   ‚ùå Test TDD cr√≠tico fall√≥")
                print(f"   üìÑ Salida: {result.stdout}")
                print(f"   üìÑ Error: {result.stderr}")
                self.execution_results['tdd_critical_test'] = False
                self.overall_success = False
                return False
                
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ Timeout en test TDD cr√≠tico")
            self.execution_results['tdd_critical_test'] = False
            self.overall_success = False
            return False
        except Exception as e:
            print(f"   ‚ùå Excepci√≥n en test TDD cr√≠tico: {e}")
            self.execution_results['tdd_critical_test'] = False
            self.overall_success = False
            return False
    
    def execute_step_05_pytest_basic_collection(self) -> bool:
        """
        Paso 5: Verificar pytest collection b√°sico.
        
        Returns:
            True si pytest --collect-only funciona
        """
        print(f"\n5Ô∏è‚É£ EJECUTANDO: pytest --collect-only b√°sico...")
        
        try:
            # Ejecutar pytest --collect-only
            result = subprocess.run([
                sys.executable, '-m', 'pytest', 
                '--collect-only', '-q'
            ], capture_output=True, text=True, cwd=self.project_root, timeout=60)
            
            # Verificar que no hay errores cr√≠ticos
            critical_errors = [
                'ModuleNotFoundError',
                'ImportError', 
                'FAILED',
                'ERROR'
            ]
            
            has_critical_errors = any(error in result.stderr for error in critical_errors)
            
            if result.returncode == 0 and not has_critical_errors:
                print(f"   ‚úÖ pytest collection b√°sico exitoso")
                print(f"   üìä Sin errores cr√≠ticos de importaci√≥n")
                self.execution_results['pytest_basic_collection'] = True
                return True
            else:
                print(f"   ‚ö†Ô∏è pytest collection con problemas menores")
                print(f"   üìÑ C√≥digo retorno: {result.returncode}")
                if result.stderr:
                    print(f"   üìÑ Errores: {result.stderr[:200]}...")
                self.execution_results['pytest_basic_collection'] = False
                # No marcar como fallo cr√≠tico si es solo advertencias
                return True
                
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ Timeout en pytest collection b√°sico")
            self.execution_results['pytest_basic_collection'] = False
            return False
        except Exception as e:
            print(f"   ‚ùå Excepci√≥n en pytest collection b√°sico: {e}")
            self.execution_results['pytest_basic_collection'] = False
            return False
    
    def execute_step_06_validate_critical_imports(self) -> bool:
        """
        Paso 6: Validar imports cr√≠ticos directamente.
        
        Returns:
            True si todos los imports cr√≠ticos funcionan
        """
        print(f"\n6Ô∏è‚É£ EJECUTANDO: Validaci√≥n de imports cr√≠ticos...")
        
        # Cambiar al directorio del proyecto
        original_cwd = os.getcwd()
        os.chdir(self.project_root)
        
        try:
            # Test imports cr√≠ticos
            critical_imports = [
                ('src.db.database', 'DatabaseConnection'),
                ('src.services.product_service', 'ProductService'),
                ('src.helpers.validation_helper', 'ValidationHelper'),
                ('src.helpers.logging_helper', 'LoggingHelper'),
            ]
            
            failed_imports = []
            successful_imports = []
            
            for module_name, class_name in critical_imports:
                try:
                    module = __import__(module_name, fromlist=[class_name])
                    getattr(module, class_name)
                    successful_imports.append(f"{module_name}.{class_name}")
                    print(f"   ‚úÖ {module_name}.{class_name}")
                except Exception as e:
                    failed_imports.append(f"{module_name}.{class_name}: {e}")
                    print(f"   ‚ùå {module_name}.{class_name}: {e}")
            
            # Test psutil espec√≠ficamente
            try:
                import psutil
                successful_imports.append("psutil")
                print(f"   ‚úÖ psutil")
            except ImportError as e:
                failed_imports.append(f"psutil: {e}")
                print(f"   ‚ùå psutil: {e}")
            
            success_rate = len(successful_imports) / (len(successful_imports) + len(failed_imports)) * 100
            
            if success_rate >= 80:
                print(f"   üìä Imports cr√≠ticos: {success_rate:.1f}% exitosos")
                self.execution_results['critical_imports'] = True
                return True
            else:
                print(f"   üìä Imports cr√≠ticos: {success_rate:.1f}% exitosos (insuficiente)")
                self.execution_results['critical_imports'] = False
                self.overall_success = False
                return False
                
        except Exception as e:
            print(f"   ‚ùå Error en validaci√≥n de imports: {e}")
            self.execution_results['critical_imports'] = False
            self.overall_success = False
            return False
        finally:
            # Restaurar directorio original
            os.chdir(original_cwd)
    
    def generate_execution_report(self):
        """Generar reporte completo de ejecuci√≥n."""
        print(f"\nüìä === REPORTE DE EJECUCI√ìN TDD ===")
        print(f"="*60)
        
        # Resultados por paso
        print(f"üìà RESULTADOS POR PASO:")
        for step, result in self.execution_results.items():
            status = "‚úÖ EXITOSO" if result else "‚ùå FALLIDO"
            print(f"   ‚Ä¢ {step.replace('_', ' ').title()}: {status}")
        
        # Estad√≠sticas generales
        total_steps = len(self.execution_results)
        successful_steps = sum(self.execution_results.values())
        success_rate = (successful_steps / total_steps) * 100 if total_steps > 0 else 0
        
        print(f"\nüìä ESTAD√çSTICAS GENERALES:")
        print(f"   ‚Ä¢ Total pasos ejecutados: {total_steps}")
        print(f"   ‚Ä¢ Pasos exitosos: {successful_steps}")
        print(f"   ‚Ä¢ Pasos fallidos: {total_steps - successful_steps}")
        print(f"   ‚Ä¢ Tasa de √©xito: {success_rate:.1f}%")
        
        # Estado final
        print(f"\nüéØ ESTADO FINAL:")
        if self.overall_success and success_rate >= 80:
            print(f"‚úÖ CORRECCIONES TDD EXITOSAS")
            print(f"üöÄ Sistema listo para an√°lisis de cobertura")
            print(f"üìã Pr√≥ximo paso: pytest --cov=src --cov-report=html tests/")
        elif success_rate >= 60:
            print(f"‚ö†Ô∏è CORRECCIONES MAYORMENTE EXITOSAS")
            print(f"üîç Revisar pasos fallidos antes de continuar")
            print(f"üõ†Ô∏è Resolver problemas menores identificados")
        else:
            print(f"‚ùå CORRECCIONES REQUIEREN ATENCI√ìN")
            print(f"üö® Resolver problemas cr√≠ticos antes de continuar")
            print(f"üõ†Ô∏è Revisar logs y errores detallados")
        
        return success_rate >= 80
    
    def run_all_executions(self) -> bool:
        """
        Ejecutar todas las correcciones TDD en secuencia.
        
        Returns:
            True si la ejecuci√≥n general fue exitosa
        """
        print(f"\nüîß EJECUTANDO TODAS LAS CORRECCIONES TDD...")
        print(f"="*60)
        
        # Lista de pasos de ejecuci√≥n
        execution_steps = [
            self.execute_step_01_install_psutil,
            self.execute_step_02_validate_quick_fixes,
            self.execute_step_03_pytest_collection_test,
            self.execute_step_04_run_critical_tdd_test,
            self.execute_step_05_pytest_basic_collection,
            self.execute_step_06_validate_critical_imports
        ]
        
        # Ejecutar pasos secuencialmente
        for i, step_func in enumerate(execution_steps, 1):
            try:
                step_func()
                # Pausa breve entre pasos
                time.sleep(1)
            except Exception as e:
                print(f"   üí• Error cr√≠tico en paso {i}: {e}")
                self.overall_success = False
        
        # Generar reporte final
        return self.generate_execution_report()


def run_tdd_corrections_execution():
    """Funci√≥n principal para ejecutar correcciones TDD."""
    print("\n" + "="*70)
    print("üöÄ EJECUTANDO CORRECCIONES TDD FASE 5A")
    print("="*70)
    print("üìã Metodolog√≠a: Test-Driven Development")
    print("üéØ Objetivo: Validar correcciones implementadas")
    print("üìä Expectativa: >80% √©xito para continuar")
    print("="*70)
    
    executor = TDDCorrectionsExecutor()
    success = executor.run_all_executions()
    
    print("\n" + "="*70)
    print("üìä EJECUCI√ìN TDD COMPLETADA")
    print("="*70)
    
    if success:
        print("üéâ √âXITO: Correcciones TDD funcionando correctamente")
        print("üìà Sistema preparado para an√°lisis de cobertura")
        print("üéØ Comando recomendado: pytest --cov=src --cov-report=html tests/")
        return True
    else:
        print("‚ö†Ô∏è ATENCI√ìN: Algunos problemas detectados")
        print("üîç Revisar reporte detallado arriba")
        print("üõ†Ô∏è Resolver problemas antes de continuar")
        return False


if __name__ == '__main__':
    print("üé¨ Iniciando Ejecuci√≥n de Correcciones TDD...")
    success = run_tdd_corrections_execution()
    
    if success:
        print(f"\n‚úÖ EJECUCI√ìN EXITOSA - Continuar con FASE 5A")
        sys.exit(0)
    else:
        print(f"\n‚ö†Ô∏è EJECUCI√ìN CON PROBLEMAS - Revisar y corregir")
        sys.exit(1)
